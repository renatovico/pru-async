worker_processes 1;
worker_rlimit_nofile 65536;

events {
    worker_connections 16384;
    multi_accept on;
    use epoll;
}
http {
    # access_log off for performance (configure as needed)
    access_log off;
    log_not_found off;
    server_tokens off;

    # gzip off for latency/CPU tradeoff
    gzip off;

    # TCP & buffering optimizations
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;

    keepalive_timeout 30;
    keepalive_requests 512;

    reset_timedout_connection on;

    # Buffer & body limits (mirroring lb config, tuned for small JSON bodies)
    client_body_buffer_size 4k;
    client_header_buffer_size 1k;
    large_client_header_buffers 2 2k;
    output_buffers 1 4k;
    postpone_output 1460;
    client_max_body_size 256k;

    open_file_cache max=2048 inactive=2s;
    open_file_cache_valid 10s;
    open_file_cache_min_uses 2;
    open_file_cache_errors off;

    types { }
    default_type application/json;
    # DNS resolver for Docker internal hostnames used in Lua cosockets
    resolver 127.0.0.11 ipv6=off valid=30s;
    # Increase timer limits to accommodate background retry tasks (also optimized logic to use one timer per request)
    lua_max_running_timers 10240;
    lua_max_pending_timers 10240;

    # Upstreams for processors
    upstream payment_default { server payment-processor-default:8080; }
    upstream payment_fallback { server payment-processor-fallback:8080; }

    server {
        listen 3000 backlog=256;
        server_name _;

        # Tight client header/body timeouts (fail fast)
        client_body_timeout 5s;
        client_header_timeout 5s;

        # Primary payment endpoint; mirrors request to fallback processor.
                location = /payments {
                        if ($request_method != POST) { return 405; }
                        lua_need_request_body on;
                        content_by_lua_block {
                                local cjson = require 'cjson.safe'
                                ngx.req.read_body()
                                local body = ngx.req.get_body_data() or ''
                                local data = cjson.decode(body)
                                if not data or not data.correlationId or data.amount == nil then
                                        ngx.status = 400
                                        ngx.say('{"error":"Bad Request"}')
                                        return
                                end
                                -- Build requestedAt timestamp
                                local now = ngx.now(); local sec = math.floor(now); local ms = math.floor((now-sec)*1000)
                                local ts = os.date('!%Y-%m-%dT%H:%M:%S', sec)..string.format('.%03dZ', ms)
                                data.requestedAt = ts
                                local cid = tostring(data.correlationId):gsub([["\\]], function(m) return '\\'..m end)
                                local json_payload = '{"correlationId":"'..cid..'","amount":'..tostring(data.amount)..',"requestedAt":"'..ts..'"}'

                                -- Early client response
                                ngx.status = 201
                                ngx.say('{"message":"Payment created"}')
                                ngx.eof()  -- flush as early as possible

                                local max_retries = 1000
                                local delay = 0.1  -- seconds between retries (500ms)

                                local function log(level, msg)
                                    ngx.log(level, '[payments] ', msg)
                                end

                                                                local function post(processor)
                                                                    local full_host = 'payment-processor-'..processor
                                                                    local base_url = 'http://'..full_host..':8080'
                                                    local sock = ngx.socket.tcp(); sock:settimeout(6000)
                                                                    local ok, cerr = sock:connect(full_host, 8080)
                                                                    if not ok then if sock then sock:close() end; return false, nil, 'connect:'..tostring(cerr)..' url='..base_url end
                                                                    local req = 'POST /payments HTTP/1.1\r\nHost: '..full_host..'\r\nContent-Type: application/json\r\nContent-Length: '..#json_payload..'\r\nConnection: close\r\n\r\n'..json_payload
                                                    local bytes, serr = sock:send(req)
                                                                    if not bytes then sock:close(); return false, nil, 'send:'..tostring(serr)..' url='..base_url end
                                                    local status_line = sock:receive('*l') or ''
                                                    local status = tonumber(status_line:match('HTTP/%d%.%d%s+(%d+)')) or 0
                                                    -- headers
                                                    while true do local l = sock:receive('*l'); if not l or l == '' then break end end
                                                    -- body (may be empty)
                                                    local chunks = {}
                                                    while true do
                                                        local chunk, rerr, partial = sock:receive(8192)
                                                        if chunk then
                                                            chunks[#chunks+1] = chunk
                                                        elseif partial and #partial > 0 then
                                                            chunks[#chunks+1] = partial
                                                        end
                                                        if not chunk then break end
                                                    end
                                                    sock:close()
                                                    local resp_body = table.concat(chunks)
                                                    if #resp_body > 400 then resp_body = resp_body:sub(1,400)..'...[truncated]' end
                                                                        if status >= 200 and status < 300 then
                                                                            return true, resp_body, nil, base_url
                                                                        else
                                                                            return false, resp_body, 'status:'..status, base_url
                                                                        end
                                                end

                                local epoch_ts = sec + (ms/1000)
                                local cid_raw = tostring(data.correlationId)
                                local function incr_success(pname)
                                    local redis = require 'resty.redis'
                                    local r = redis:new(); r:set_timeout(200)
                                    local ok, err = r:connect('redis_pru', 6379)
                                    if not ok then ngx.log(ngx.ERR, '[payments] redis incr connect fail ', err); return end
                                    r:incr('payments:count:'..pname)
                                    r:incrbyfloat('payments:amount:'..pname, data.amount)
                                    local member = '{"a":"'..tostring(data.amount)..'","c":"'..cid_raw..'"}'
                                    r:zadd('payments_log_'..pname, epoch_ts, member)
                                    r:set_keepalive(60000, 50)
                                end

                                -- Single timer handling all retries sequentially to avoid many concurrent timers.
                                ngx.timer.at(0, function(premature)
                                    if premature then return end
                                    for attempt_no = 1, max_retries do
                                        local ok, body, err, url = post('default')
                                        if ok then
                                            incr_success('default')
                                            log(ngx.INFO, 'attempt '..attempt_no..' default success url='..tostring(url)..' body='..tostring(body))
                                            return
                                        else
                                            log(ngx.WARN, 'attempt '..attempt_no..' default failed '..tostring(err)..' body='..tostring(body))
                                        end
                                        if attempt_no > 5 then
                                            local okfb, bodyfb, errfb, urlfb = post('fallback')
                                            if okfb then
                                                incr_success('fallback')
                                                log(ngx.INFO, 'attempt '..attempt_no..' fallback success url='..tostring(urlfb)..' body='..tostring(bodyfb))
                                                return
                                            else
                                                log(ngx.ERR, 'attempt '..attempt_no..' fallback failed '..tostring(errfb)..' body='..tostring(bodyfb))
                                            end
                                        else
                                            log(ngx.DEBUG, 'attempt '..attempt_no..' skipping fallback (preferring default until attempt 6)')
                                        end
                                        if attempt_no < max_retries then
                                            ngx.sleep(delay)
                                        else
                                            log(ngx.ERR, 'max retries reached without success')
                                        end
                                    end
                                end)
                        }
                }

        # Internal mirror location (no response returned to client).
        location = /_mirror_fallback {
            internal;
            proxy_pass http://payment_fallback$request_uri;
            proxy_set_header Host $host;
            proxy_set_header Content-Type $content_type;
            proxy_set_header Content-Length $content_length;
        }

        # Payments summary with optional from/to window (?from=ISO8601&to=ISO8601)
        location = /payments-summary {
            if ($request_method != GET) { return 405; }
            content_by_lua_block {
                local cjson = require 'cjson.safe'
                local redis = require 'resty.redis'
                local function parse_iso(ts)
                    if not ts or ts == '' then return nil end
                    local Y,m,d,H,M,S,ms = ts:match('^(%d%d%d%d)%-(%d%d)%-(%d%d)T(%d%d):(%d%d):(%d%d)%.?(%d?%d?%d?)Z$')
                    if not Y then return nil end
                    ms = ms or ''
                    ms = ms .. string.rep('0', 3-#ms)
                    local epoch = os.time({year=Y, month=m, day=d, hour=H, min=M, sec=S})
                    return epoch + (tonumber(ms)/1000)
                end
                local arg_from = ngx.var.arg_from
                local arg_to = ngx.var.arg_to
                local from_f = parse_iso(arg_from)
                local to_f = parse_iso(arg_to)
                local from_score = from_f and tostring(from_f) or '-inf'
                local to_score = to_f and tostring(to_f) or '+inf'
                local red = redis:new(); red:set_timeout(800)
                local ok, err = red:connect('redis_pru', 6379)
                if not ok then
                    ngx.status = 500
                    ngx.say('{"error":"summary_unavailable"}')
                    return
                end
                local processors = {'default','fallback'}
                local out = {}
                for _,p in ipairs(processors) do
                    out[p] = { totalRequests = 0, totalAmount = 0.0 }
                    local res, rerr = red:zrangebyscore('payments_log_'..p, from_score, to_score)
                    if res and type(res) == 'table' then
                        out[p].totalRequests = #res
                        local total = 0.0
                        for _,entry in ipairs(res) do
                            local obj = cjson.decode(entry)
                            if obj and obj.a then total = total + tonumber(obj.a) end
                        end
                        out[p].totalAmount = tonumber(string.format('%.2f', total))
                    end
                end
                red:set_keepalive(60000, 50)
                ngx.status = 200
                ngx.say(cjson.encode(out))
            }
        }

        location = /purge-payments {
            if ($request_method != POST) { return 405; }
            content_by_lua_block {
                local redis = require 'resty.redis'
                local r = redis:new(); r:set_timeout(800)
                local ok, err = r:connect('redis_pru', 6379)
                if not ok then
                    ngx.status = 500
                    ngx.say('{"error":"purge_unavailable"}')
                    return
                end
                -- Explicitly delete known keys (faster & safer than FLUSHDB in shared Redis)
                r:del('payments:count:default','payments:count:fallback',
                      'payments:amount:default','payments:amount:fallback',
                      'payments_log_default','payments_log_fallback')
                r:set_keepalive(60000, 50)
                ngx.status = 200
                ngx.say('{"message":"purged"}')
            }
        }

        location / {
            return 404 '{"error":"Not Found"}';
        }
    }
}
