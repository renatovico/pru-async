worker_processes 1;

events { worker_connections 1024; }

http {
    sendfile on;
    keepalive_timeout 65;
    types { }
    default_type application/json;
    # DNS resolver for Docker internal hostnames used in Lua cosockets
    resolver 127.0.0.11 ipv6=off valid=30s;

    # Upstreams for processors
    upstream payment_default { server payment-processor-default:8080; }
    upstream payment_fallback { server payment-processor-fallback:8080; }

    server {
        listen 3000;
        server_name _;

        # Primary payment endpoint; mirrors request to fallback processor.
                location = /payments {
                        if ($request_method != POST) { return 405; }
                        lua_need_request_body on;
                        content_by_lua_block {
                                local cjson = require 'cjson.safe'
                                ngx.req.read_body()
                                local body = ngx.req.get_body_data() or ''
                                local data = cjson.decode(body)
                                if not data or not data.correlationId or data.amount == nil then
                                        ngx.status = 400
                                        ngx.say('{"error":"Bad Request"}')
                                        return
                                end
                                -- Build requestedAt timestamp
                                local now = ngx.now(); local sec = math.floor(now); local ms = math.floor((now-sec)*1000)
                                local ts = os.date('!%Y-%m-%dT%H:%M:%S', sec)..string.format('.%03dZ', ms)
                                data.requestedAt = ts
                                local cid = tostring(data.correlationId):gsub([["\\]], function(m) return '\\'..m end)
                                local json_payload = '{"correlationId":"'..cid..'","amount":'..tostring(data.amount)..',"requestedAt":"'..ts..'"}'

                                -- Early client response
                                ngx.status = 201
                                ngx.say('{"message":"Payment created"}')
                                ngx.eof()  -- flush as early as possible

                                local max_retries = 20
                                local delay = 0.1  -- seconds between retries (can be tuned)

                                local function log(level, msg)
                                    ngx.log(level, '[payments] ', msg)
                                end

                                                                local function post(processor)
                                                                    local full_host = 'payment-processor-'..processor
                                                                    local base_url = 'http://'..full_host..':8080'
                                                    local sock = ngx.socket.tcp(); sock:settimeout(6000)
                                                                    local ok, cerr = sock:connect(full_host, 8080)
                                                                    if not ok then if sock then sock:close() end; return false, nil, 'connect:'..tostring(cerr)..' url='..base_url end
                                                                    local req = 'POST /payments HTTP/1.1\r\nHost: '..full_host..'\r\nContent-Type: application/json\r\nContent-Length: '..#json_payload..'\r\nConnection: close\r\n\r\n'..json_payload
                                                    local bytes, serr = sock:send(req)
                                                                    if not bytes then sock:close(); return false, nil, 'send:'..tostring(serr)..' url='..base_url end
                                                    local status_line = sock:receive('*l') or ''
                                                    local status = tonumber(status_line:match('HTTP/%d%.%d%s+(%d+)')) or 0
                                                    -- headers
                                                    while true do local l = sock:receive('*l'); if not l or l == '' then break end end
                                                    -- body (may be empty)
                                                    local chunks = {}
                                                    while true do
                                                        local chunk, rerr, partial = sock:receive(8192)
                                                        if chunk then
                                                            chunks[#chunks+1] = chunk
                                                        elseif partial and #partial > 0 then
                                                            chunks[#chunks+1] = partial
                                                        end
                                                        if not chunk then break end
                                                    end
                                                    sock:close()
                                                    local resp_body = table.concat(chunks)
                                                    if #resp_body > 400 then resp_body = resp_body:sub(1,400)..'...[truncated]' end
                                                                        if status >= 200 and status < 300 then
                                                                            return true, resp_body, nil, base_url
                                                                        else
                                                                            return false, resp_body, 'status:'..status, base_url
                                                                        end
                                                end

                                local function attempt(attempt_no)
                                    -- Try default first
                                                                            local ok, body, err, url = post('default')
                                                                            if ok then
                                                                                log(ngx.INFO, 'attempt '..attempt_no..' default success url='..tostring(url)..' body='..tostring(body))
                                        return
                                    else
                                                                                log(ngx.WARN, 'attempt '..attempt_no..' default failed '..tostring(err)..' body='..tostring(body))
                                    end
                                    -- Try fallback
                                                                            local okfb, bodyfb, errfb, urlfb = post('fallback')
                                                                            if okfb then
                                                                                log(ngx.INFO, 'attempt '..attempt_no..' fallback success url='..tostring(urlfb)..' body='..tostring(bodyfb))
                                        return
                                    else
                                                                                log(ngx.ERR, 'attempt '..attempt_no..' fallback failed '..tostring(errfb)..' body='..tostring(bodyfb))
                                    end
                                    if attempt_no < max_retries then
                                        local next_delay = delay
                                        ngx.timer.at(next_delay, function(premature)
                                            if premature then return end
                                            attempt(attempt_no + 1)
                                        end)
                                    else
                                        log(ngx.ERR, 'max retries reached without success')
                                    end
                                end

                                -- Kick off first async attempt after response (run in timer to ensure response flush)
                                ngx.timer.at(0, function() attempt(1) end)
                        }
                }

        # Internal mirror location (no response returned to client).
        location = /_mirror_fallback {
            internal;
            proxy_pass http://payment_fallback$request_uri;
            proxy_set_header Host $host;
            proxy_set_header Content-Type $content_type;
            proxy_set_header Content-Length $content_length;
        }

        # Static summary placeholder (no dynamic counters without Lua/external service).
        location = /payments-summary {
            if ($request_method != GET) { return 405; }
            return 200 '{"default":{"totalRequests":0,"totalAmount":0.00},"fallback":{"totalRequests":0,"totalAmount":0.00}}';
        }

        location = /purge-payments {
            if ($request_method != POST) { return 405; }
            return 200 '{"message":"purged"}';
        }

        location / {
            return 404 '{"error":"Not Found"}';
        }
    }
}
