worker_processes auto;
worker_rlimit_nofile 65536;

events {
	worker_connections 8192;
	multi_accept on;
	use epoll;
}

http {
	# Fixed syntax: key must be specified (using "" as a constant for global limit)
	limit_conn_zone $binary_remote_addr zone=perip:10m;
	limit_conn_zone $server_name zone=perserver:10m;

	# Status code to return when connection limit exceeded
	limit_conn_status 503;
	limit_conn_log_level warn;

	access_log off;
	log_not_found off;
	server_tokens off;

	# gzip is disabled for maximum throughput
	gzip off;

	# TCP optimizations
	sendfile on;
	tcp_nopush on;
	tcp_nodelay on;

	# Reduce keepalive settings to prevent connection pooling from bypassing limits
	keepalive_timeout 5;
	keepalive_requests 100;
	reset_timedout_connection on;

	# Buffer and timeout tuning
	client_body_buffer_size 16k;
	client_header_buffer_size 4k;
	large_client_header_buffers 4 8k;
	output_buffers 2 32k;
	postpone_output 1460;
	client_max_body_size 2M;

	upstream api {
		server api01:3000 max_conns=1536;
		server api02:3000 max_conns=1536;
		keepalive 64;
	}

	server {
		listen 9999 http2 fastopen=256 reuseport;

		# Apply connection limits
		limit_conn perserver 1536;
		limit_conn perip 100;

		# Minimal security headers
		add_header X-Content-Type-Options "nosniff" always;
		add_header X-Frame-Options "SAMEORIGIN" always;

		location / {
			proxy_pass http://api;
			proxy_http_version 1.1;
			proxy_set_header Host $host;
			proxy_set_header X-Real-IP $remote_addr;
			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header X-Forwarded-Proto $scheme;

			# Close connections to backend rather than keeping them open
			proxy_set_header Connection "";

			proxy_connect_timeout 2s;
			proxy_send_timeout 10s;
			proxy_read_timeout 10s;
			proxy_buffering on;
			proxy_buffers 16 16k;
			proxy_busy_buffers_size 32k;
			proxy_max_temp_file_size 0;
			proxy_cache off;
			proxy_intercept_errors off;
		}
	}
}
